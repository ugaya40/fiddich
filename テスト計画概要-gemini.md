# Fiddich テスト計画概要

## 1. はじめに

本ドキュメントは、状態管理ライブラリ「Fiddich」の品質と信頼性を保証するための、新しいテスト計画の概要を定義するものです。既存のテスト群は品質上の懸念からすべて撤廃し、本計画に基づき、ゼロからテストスイートを再構築します。

目的は、公開APIのすべての振る舞いをユーザー視点で網羅的に検証し、内部実装の複雑なエッジケースを潰し込み、将来の機能追加やリファクタリングに対する堅牢なセーフティネットを確立することです。

## 2. テストの基本方針

- **振る舞いを検証する**: テストは内部実装の詳細ではなく、APIの仕様と`DESIGN.MD`に定義された振る舞いを検証します。
- **ユーザー視点を重視**: ライブラリの利用者が遭遇しうる、現実的で意味のあるシナリオを優先的にテストします。
- **完全な分離**: 各テストケースは他のテストから完全に独立しており、実行順序に依存せず、単独で成功または失敗しなければなりません。
- **決定論的であること**: テストは外部要因（時間、ネットワークなど）に依存せず、何度実行しても同じ結果を返す必要があります。
- **ドキュメントとして機能**: テストケース自体が、ライブラリの具体的な使用方法や振る舞いの仕様を示す生きたドキュメントとなるように記述します。

### 3. テストレベルと検証項目

テストは以下のレベルに分類し、それぞれ特定の機能群と観点を検証します。

#### 3.1. 単体テスト (Unit Tests)

個別のAPIや機能が、他の部分から隔離された状態で、仕様通りに単独で動作することを検証します。

-   **3.1.1. コアAPI (`createCell`, `createComputed`, `get`, `set`, `touch`)**
    -   **観点**:
        -   `createCell`: 正しい初期値で生成されるか。`compare`オプションは機能するか。
        -   `createComputed`: 遅延実行、基本的な依存関係の追跡、キャッシュ機能が正しく動作するか。
        -   `get`/`set`/`touch`: それぞれが仕様通りに機能するか。`set`時の`dispose`呼び出しは機能するか。

-   **3.1.2. トランザクションの基本操作 (`atomicUpdate`内の各`ops`)**
    -   **観点**:
        -   `ops.get`/`ops.set`: トランザクション内での値の読み書きが正しくバッファされるか。
        -   `ops.rejectAllChanges`: コンテキストの変更がすべて破棄されるか。
        -   `ops.dispose`: `dispose`の実行が予約されるか。

-   **3.1.3. 同時実行制御トークン**
    -   **観点**:
        -   `GuardToken`, `ExclusiveToken`, `SequencerToken`が、それぞれ競合・排他・直列化のロジックを正しくカプセル化できているか。

#### 3.2. 統合テスト (Integration Tests)

複数の機能が連携した際に、システム全体として正しく動作することを検証します。

-   **3.2.1. リアクティビティと更新伝播**
    -   **観点**:
        -   **基本的な依存関係**: `Cell` -> `Computed` の変更が正しく伝播するか。
        -   **連鎖的な依存関係**: `A -> B -> C` のように、変更が連鎖的に伝播し、Cが正しく再計算されるか。
        -   **ダイヤモンド依存**: `A -> B, A -> C, B -> D, C -> D` の菱形依存において、Dの再計算が一度しか実行されないか。
        -   **動的な依存関係**: `Computed`の依存関係が動的に変化した場合に、依存情報が正しく更新されるか。

-   **3.2.2. `atomicUpdate`のトランザクション全体テスト**
    -   **観点**:
        -   **原子性(Atomicity)**: エラー発生時に、すべての変更がロールバックされるか。
        -   **分離性(Isolation)**: トランザクション中の変更が、完了まで外部から観測不能であるか。
        -   **ネストした`atomicUpdate`**: 入れ子トランザクションが正しく機能するか。

-   **3.2.3. エラーハンドリングとエッジケース**
    -   **観点**:
        -   **循環依存**: 静的および動的な循環依存を正しく検出し、エラーをスローするか。
        -   **リソース管理**: `[Symbol.dispose]`が呼ばれた際に、依存グラフから正しく自身を削除できるか。

#### 3.3. React連携テスト (E2E / Integration)

実際のReact環境で、ライブラリがUIフレームワークと正しく連携して動作することを検証します。

-   **観点**:
    -   `useValue`フックによるコンポーネントの再レンダリングが正しく行われるか。
    -   `pending`状態と`React.Suspense`が正しく連携するか。
    -   コンポーネントのアンマウント時に、内部の購読がクリーンアップされるか（メモリリーク防止）。

## 4. 特別に注視すべき項目

以下の項目は、ライブラリの複雑性が高く、バグが潜在しやすい領域であるため、特に重点的かつ多角的なテストを設計・実装する必要があります。

- **動的な依存関係の変更**: `Computed`の依存先が実行ごとに変わるシナリオ。特に、依存関係の「追加」「削除」「入れ替え」が同時に発生する複雑なケースで、内部の依存グラフが完全に正確な状態を維持できるか。
- **`rejectAllChanges`の完全性**: 値の復元だけでなく、`toDispose`セットのクリア、`newlyInitialized`セットのクリアなど、`AtomicContext`のあらゆる状態がトランザクション開始前に巻き戻ることを保証する必要がある。
- **非同期`atomicUpdate`と`SequencerToken`の組み合わせ**: 非同期処理のキューイングと実行順序の保証は、タイミングの問題が絡むため、特に慎重なテストが必要。
- **ネストした`atomicUpdate`とエラーハンドリング**: 内側の`atomicUpdate`でエラーが発生した際に、外側の`atomicUpdate`も含めて、すべての状態が正しくロールバックされるか。

## 5. テスト環境

- **フレームワーク**: Vitest
- **実行環境**: jsdom
- **実行コマンド**: `npm run test`, `npm run test:ui`
