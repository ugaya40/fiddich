# 循環依存検出の課題

## 2種類の循環依存問題

### 1. 静的循環依存（Static Circular Dependency）

**定義：**
同一の計算スタック内で、あるComputedが自分自身の計算を再帰的に要求する状態。

**具体例：**
```typescript
const computedA = createComputed(({ get }) => {
  return get(computedA) + 1;  // 自己参照
});

// または間接的な循環
const computedA = createComputed(({ get }) => get(computedB));
const computedB = createComputed(({ get }) => get(computedA));
```

**発生メカニズム：**
1. computedA.compute()実行開始
2. その中でget(computedA)またはget(computedB)を呼ぶ
3. 最終的に再度computedA.compute()が呼ばれる
4. スタックオーバーフローまたは無限再帰

**特徴：**
- 依存関係の定義自体に循環がある
- 初回計算時に即座に発生
- 同期的な呼び出しチェーン内で検出可能

### 2. 動的循環依存（Dynamic/Non-convergent Circular Dependency）

**定義：**
実行時の条件によって依存関係が変化し、値の更新が収束せず永続的に続く状態。

**具体例：**
```typescript
const control = createCell(true);
const cellA = createCell(1);

const computedA = createComputed(({ get }) => {
  return get(control) ? get(cellA) : get(computedB) + 1;
});

const computedB = createComputed(({ get }) => {
  return get(computedA) + 1;
});

// control=trueの時：A→cellA, B→A（循環なし）
// control=falseの時：A→B→A（循環発生）
// さらに値が 3→5→7→9... と変化し続ける
```

**発生メカニズム：**
1. set(control, false)で依存関係が変化
2. computedAがcomputedBに依存するようになる
3. computedBは既にcomputedAに依存
4. 相互に依存し、かつ+1により値が変化し続ける
5. 各計算は正常に完了するが、新たな計算が永続的に発生

**特徴：**
- 実行時の状態によって循環が発生
- 各個別の計算は正常に完了
- 値が収束しない（常に変化する）
- 非同期的に連鎖が続く可能性

## 現在の実装の問題点

### withCircularDetection（グローバルcomputingSet）の問題
- 静的循環のみ検出可能
- 動的循環は各計算が独立して完了するため検出不可
- グローバル変数のため並行実行時に誤検出の可能性

### 解決の方向性
- 起点ごとの独立したcomputingChainによる検出
- 値変更起点（set/touch）と計算要求起点（get/ops.get）の区別
- valueDirtyの構造変更によるグループ管理
- computedの初期化時・再計算時に考慮が必要