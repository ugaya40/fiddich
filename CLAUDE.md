# CLAUDE.md

このファイルは、このリポジトリでコードを扱う際のClaude Code (claude.ai/code) 向けのガイダンスです。

## 🚨 最重要事項 🚨
**このプロジェクトでは絶対に常に日本語で応対し、日本語で考えてください。英語での応答は厳禁です。**
**コードのコメントはコードを見れば明快なものなどは記述しない事。**

### 開発時の重要な注意事項

#### ⚠️ Claudeが過去に犯した重大な失敗と教訓 ⚠️

**循環依存検出問題での失敗（2025年1月）:**
- 場当たり的な対応を繰り返し、コードベースを混乱させた
- コードを理解せずに修正を試み、ユーザーの生産性を著しく損なった
- デバッグコードを無計画に追加し、問題を複雑化させた

**厳守すべき作業手順:**
1. **必ずコードリーディングから始める** - 問題を理解せずにコードを書かない
2. **コード編集前に必ず説明して承認を得る** - 「こう修正します」ではなく「こう修正したいが良いか」と確認
3. **デバッグコードの追加も計画的に** - むやみにログを追加しない
4. **何度も失敗した問題では特に慎重に** - 同じ間違いを繰り返さない
5. **場当たり的な対応は絶対に避ける** - 全体を理解してから行動する

### 既存の開発時の重要な注意事項

1. **仕様の確認を最優先に**
   - 現在のコードの動作が必ずしも正しい仕様とは限らない
   - 仕様が不明確、または一貫性に疑問がある場合は必ずユーザーに確認する
   - 「現在のコードがこう動いているから、これが正しい」という思い込みは厳禁

2. **テストケースの作成**
   - テストケースは「あるべき仕様」に基づいて作成する
   - 現在のコードの動作に合わせてテストを作ってはいけない
   - テストが失敗した場合、まず「このテストが期待する動作は正しい仕様か？」を確認する

3. **実装前の確認**
   - 実装が仕様を決めるのではなく、仕様が実装を決める
   - バグかもしれない動作を見つけたら、修正前に必ず確認する
   - 一貫性のない動作を見つけたら、どちらが正しいか確認する

## プロジェクト概要

FiddichはReact向けの状態管理ライブラリです。現在、モノレポ構造から単一パッケージ構造への移行中です（バージョン0.17.0）。
基本的な設計思想はDESIGN.MDに記述してあるので常にマスターとして参照してください。もし現在の設計と乖離している部分があれば知らせてください

### 設計哲学

- **手続き的プログラミングの自然さ**: atomicUpdateスコープ内でミュータブルな操作を可能にし、開発者が慣れ親しんだ書き方を維持
- **明示的なリアクティビティ**: MobXのような暗黙的なリアクティビティではなく、Cell/Computedによる明示的な状態管理
- **リソース管理の自動化**: Symbol.disposeを活用した確実なメモリ管理
- **アプリケーションロジックの集約**: 状態とその操作を同じ場所にカプセル化し、副作用も操作の文脈内で管理

## 開発コマンド

```bash
# プロジェクトのビルド
npm run build

# 開発モード（watch）
npm run dev

# テスト実行
npm run test

# テストUIモード
npm run test:ui

# 型チェック
npm run type-check
```

## プロジェクト構造

現在の構造：
- ビルド出力: 
  - ESModules形式: `dist/index.js`
  - CommonJS形式: `dist/index.cjs`
  - TypeScript型定義: `dist/index.d.ts`
- ソースコード: `src/` ディレクトリ
- テストコード: `test/` ディレクトリ（現在未実装）
- パッケージタイプ: ESモジュール + CommonJS（tsupで両対応）

## 技術スタック

- **TypeScript 5.0+**: 最新のTypeScript機能を使用
- **tsup**: 高速なTypeScriptバンドラー
- **Vitest**: 高速なテストフレームワーク（jsdom環境）
- **React 18+**: peerDependencyとして設定

## 開発環境セットアップ

新しい構造で以下が設定済み：
- tsup設定（ESモジュール出力、型定義生成）
- Vitest設定（jsdom環境、グローバル設定）
- TypeScript設定（strict mode、最新機能）

## コーディングルール

- 出来るだけクラスを使用しないように
- 出来るだけinterfaceよりtypeを使用
- コードを読めば意図が明快なコードコメントを追加しないように
- **型安全性を最優先**: TypeScriptの型システムを最大限活用し、`as`によるキャストは極力避ける
- **オーバーロードによる型推論**: 関数のオーバーロードを使用して、型安全かつ推論が効く実装を心がける
- **コメント・エラーメッセージはすべて英語**: 国際的な開発者にも理解しやすいように
- **コメントは最小限に**: 必要不可欠な説明のみ記載

## アーキテクチャと実装の要点

詳細な状態管理の仕組みについては、[docs/architecture.md](docs/architecture.md)を参照してください。

### コアエンティティ

- **Cell**: 基本的な状態コンテナ（TC39 Signalsに類似するが独自実装）
- **Computed**: 他のCell/Computedから派生する計算値（副作用を含まない軽量な処理推奨、onChangeオプションで値変更時のコールバックも可能）
- **AtomicContext**: トランザクション管理の中核、状態変更のバッファリングと一貫性維持
- **AtomicUpdate**: 複数の状態変更を原子的に実行するためのAPI

### 決定された新たな設計方針

- atomicContextではすべてのStateのコピーを依存関係(Stateが依存しているもの、Stateに依存しているもの)・値を含め保持する
  - Stateのコピーのみを編集する
  - コミット時はStateのコピーをそのまま反映すれば良いし、ロールバック時はコピーを破棄すれば良い
- Stateのバージョンは楽観的同時実行制御のために使用されます
  - dependencyVersionは依存関係のバージョン(dependencies方向のみ)を管理します
  - valueVersionは値のバージョンを管理します
- Stateの更新やコミットは常に最小の単位で行います

### 現在の実装状況（2025年6月）

#### ✅ 実装済み
- 基本的な型定義（Cell, Computed）in `src/state.ts`
- StateCopyStoreの実装 in `src/atomicContext/`
- AtomicContextの実装（楽観的同時実行制御、Push型評価）
- AtomicUpdateの実装（トランザクション管理）
- Cell/Computedの作成関数（createCell, createComputed）
- get/set/touch/pending/disposeなどのトップレベル関数
- ops.rejectAllChanges（atomicUpdate内での全変更破棄・リセット機能）
- 循環依存検出（本体の計算時とコピー作成時の2段階）
- pending機能（非同期状態管理、React Suspense連携）
- React連携（useValueフック）
- 包括的なテストファイル（basic, atomic-update, dependency-tracking, commit-rollback, diamond-dependency等）
- TypeScript/tsup/Vitest設定

#### ❌ 未実装
- ReactiveCollection（ReactiveMap/ReactiveArray）
- createManagedObject（リソース管理の自動化）

### 最近の主要な改善

#### Rankベースの実行順序管理
- ダイヤモンド依存の問題を解決
- 各StateCopyに`rank`フィールドを追加（依存グラフの深さを表す）
- `handleValueDirty`でrank順にソートして処理
- 各Computedが正しい順序で1回だけ計算される

## 開発の進め方

### 実装の優先順位（2025年6月時点）
1. **次に実装すべきもの**
   - ReactiveCollection（ReactiveMap/ReactiveArray）の実装
   - createManagedObjectの実装

2. **その後の検討事項**
   - パフォーマンス最適化
   - より高度なReact連携機能（SSR対応等）
   - デバッグツールの提供

### デバッグ時の注意点
- Symbol.disposeはTypeScript 5.2以降の機能
- tsconfig.jsonの`lib`に`ESNext.Disposable`が含まれていることを確認
- StateCopyの管理では、originalプロパティで元のStateへの参照を保持

### ファイル命名規則
- 関数名と同じファイル名（例: createCell.ts）
- 型定義は集約（state.ts）
- ユーティリティはutil.tsに集約
